#!/usr/bin/env python3

import numpy as np
import rospy
from sensor_msgs.msg import Image, LaserScan, CameraInfo
from tf2_geometry_msgs import PoseStamped, tf2_geometry_msgs
from geometry_msgs.msg import Twist ,Point
from cv_bridge import CvBridge
import cv2
import message_filters
import math
import tf2_ros
import copy


class Driver:
    def __init__(self):
        # ---------------------------------------------------
        #   Get team, hunter and prey
        # ---------------------------------------------------
        self.team = ''
        self.team_colors = []
        self.hunter = ''
        self.hunter_colors = []
        self.prey = ''
        self.prey_colors = []
        self.player = ''
        self.allplayers = ''
        self.team_identification()
        # ---------------------------------------------------
        #   Topics to subscribe and subscription
        # ---------------------------------------------------
        topic_camera = "/" + self.player + '/camera/rgb/image_raw'
        topic_backcamera = "/" + self.player + '/back_camera/rgb/image_raw'
        topic_camera_info = "/" + self.player + '/camera/rgb/camera_info'
        topic_backcamera_info = "/" + self.player + '/back_camera/rgb/camera_info'
        topic_laser = "/" + self.player + '/scan'
        self.subscriber_laser = rospy.Subscriber(topic_laser, LaserScan, self.getLidarPointsCallback)
        self.subscriber_camera = message_filters.Subscriber(topic_camera, Image)
        self.subscriber_backcamera = message_filters.Subscriber(topic_backcamera, Image)
        self.subscriber_camera_info = message_filters.Subscriber(topic_camera_info, CameraInfo)
        self.subscriber_backcamera_info = message_filters.Subscriber(topic_backcamera_info, CameraInfo)
        # ---------------------------------------------------
        #   Get image from the cameras
        # ---------------------------------------------------
        self.bridge = CvBridge()
        self.backcameraimage = None
        self.frontcameraimage = None
        ts_image = message_filters.TimeSynchronizer([self.subscriber_camera, self.subscriber_backcamera], 1)
        ts_image.registerCallback(self.getCameraCallback)
        self.back_team_centroids = []
        self.back_hunter_centroids = []
        self.back_prey_centroids = []
        self.front_team_centroids = []
        self.front_hunter_centroids = []
        self.front_prey_centroids = []
        # ---------------------------------------------------
        #   Get info from the cameras
        # ---------------------------------------------------
        self.front_intrinsic = None
        self.front_width = None
        self.front_height = None
        self.back_intrinsic = None
        self.back_width = None
        self.back_height = None
        ts_imageinfo = message_filters.TimeSynchronizer([self.subscriber_camera_info,
                                                         self.subscriber_backcamera_info], 1)
        ts_imageinfo.registerCallback(self.getCameraInfoCallback)
        # ---------------------------------------------------
        #   Laser points
        # ---------------------------------------------------
        self.lidarpoints_frontcamera = []
        self.lidarpoints_backcamera = []
        self.lidarpixels_frontcamera = []
        self.lidarpixels_backcamera = []
        self.lidarpixelsbig_frontcamera = []
        self.lidarpixelsbig_backcamera = []
        self.lidarcoordbig_frontcamera = []
        self.lidarcoordbig_backcamera = []
        self.tf_buffer = tf2_ros.Buffer()
        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer)
        # ---------------------------------------------------
        #   Goal
        # ---------------------------------------------------
        self.goal = PoseStamped()
        self.manual_goal_active = False
        self.angle = 0
        self.speed = 0
        # ---------------------------------------------------
        #   Publisher
        # ---------------------------------------------------
        self.publisher_command = rospy.Publisher('/' + self.player + '/cmd_vel', Twist, queue_size=1)

        self.tf_buffer = tf2_ros.Buffer()
        self.listener = tf2_ros.TransformListener(self.tf_buffer)

        self.timer = rospy.Timer(rospy.Duration(0.1), self.sendCommandCallback)

        self.goal_subscriber = rospy.Subscriber('/move_base_simple/goal', PoseStamped, self.goalReceivedCallback)

    def team_identification(self):
        self.allplayers = {'red': rospy.get_param('/red_players'),
                           'green': rospy.get_param('/green_players'),
                           'blue': rospy.get_param('/blue_players')}
        self.player = rospy.get_name().strip('/')
        #   Red color
        lower_red = np.array([0, 0, 0])
        upper_red = np.array([0, 38, 230])
        #   Green color
        lower_green = np.array([4, 144, 0])
        upper_green = np.array([42, 256, 10])
        #   Blue color
        lower_blue = np.array([105, 0, 3])
        upper_blue = np.array([255, 13, 25])
        if self.player in self.allplayers['red']:
            self.team = 'red'
            self.team_colors = [lower_red, upper_red]
            self.hunter = 'blue'
            self.hunter_colors = [lower_blue, upper_blue]
            self.prey = 'green'
            self.prey_colors = [lower_green, upper_green]
        elif self.player in self.allplayers['green']:
            self.team = 'green'
            self.team_colors = [lower_green, upper_green]
            self.hunter = 'red'
            self.hunter_colors = [lower_red, upper_red]
            self.prey = 'blue'
            self.prey_colors = [lower_blue, upper_blue]
        elif self.player in self.allplayers['blue']:
            self.team = 'blue'
            self.team_colors = [lower_blue, upper_blue]
            self.hunter = 'green'
            self.hunter_colors = [lower_green, upper_green]
            self.prey = 'red'
            self.prey_colors = [lower_red, upper_red]
        else:
            self.team = 'Alone'
            self.hunter = 'No one'
            self.prey = 'No one'

    def getCameraCallback(self, msg_front, msg_back):
        self.frontcameraimage = self.bridge.imgmsg_to_cv2(msg_front, "bgr8")
        self.backcameraimage = self.bridge.imgmsg_to_cv2(msg_back, "bgr8")
        # Variables reset
        self.back_team_centroids = []
        self.back_hunter_centroids = []
        self.back_prey_centroids = []
        self.front_team_centroids = []
        self.front_hunter_centroids = []
        self.front_prey_centroids = []
        # Get centroids
        self.Centroid(self.backcameraimage, self.back_team_centroids, 'Team')
        self.Centroid(self.backcameraimage, self.back_hunter_centroids, 'Hunter')
        self.Centroid(self.backcameraimage, self.back_prey_centroids, 'Prey')
        self.Centroid(self.frontcameraimage, self.front_team_centroids, 'Team')
        self.Centroid(self.frontcameraimage, self.front_hunter_centroids, 'Hunter')
        self.Centroid(self.frontcameraimage, self.front_prey_centroids, 'Prey')
        print('funcao teste')
        # print(self.lidarpixelsbig_backcamera)
        print(self.centroid_to_lidar(self.back_prey_centroids, self.lidarpixels_backcamera,
                                     self.lidarcoordbig_backcamera, self.lidarpixelsbig_backcamera))
        # print(self.centroid_to_lidar(self.back_team_centroids, self.lidarpixels_backcamera))
        print('input')
        print(self.back_prey_centroids)

        # TODO Meter parametro para escolher visualizar imagem ou n√£o
    def getCameraInfoCallback(self, msg_front, msg_back):
        self.front_height = msg_front.height
        self.front_width = msg_front.width
        self.front_intrinsic = np.asarray(msg_front.K).reshape(3, 3)
        self.back_height = msg_back.height
        self.back_width = msg_back.width
        self.back_intrinsic = np.asarray(msg_back.K).reshape(3, 3)

    def goalReceivedCallback(self, msg):
        # Verify if goal is in odom frame
        print('Received new goal')
        self.goal = copy.copy(msg)
        self.manual_goal_active = True


    def getLidarPointsCallback(self, msg):
        z = 0
        for idx, range in enumerate(msg.ranges):
            theta = msg.angle_min + idx * msg.angle_increment
            x = range * math.cos(theta)
            y = range * math.sin(theta)
            posestamped = PoseStamped()
            posestamped.header.frame_id = self.player + "/base_scan"
            posestamped.header.stamp = rospy.Time(0)
            point = Point()
            point.x = x
            point.y = y
            point.z = z
            posestamped.pose.position = point
            # Separate front and back points
            posestamped_front = copy.deepcopy(posestamped)
            posestamped_back = copy.deepcopy(posestamped)
            if posestamped_front.pose.position.x < 0:
                posestamped_front.pose.position.x = math.inf
                posestamped_front.pose.position.y = math.inf
            if posestamped_back.pose.position.x > 0:
                posestamped_back.pose.position.x = math.inf
                posestamped_back.pose.position.y = math.inf

            self.lidarpoints_frontcamera.append((posestamped_front.pose.position.x, posestamped_front.pose.position.y))
            self.lidarpoints_backcamera.append((posestamped_back.pose.position.x, posestamped_back.pose.position.y))

            # Tranform lidar cordenates to pixels in camera frame
            self.lidar_points_to_pixels(posestamped_back, self.player + "/back_camera_rgb_optical_frame",
                                        self.back_intrinsic, self.lidarpixels_backcamera,
                                        self.lidarpixelsbig_backcamera, self.lidarcoordbig_backcamera)
            self.lidar_points_to_pixels(posestamped_front, self.player + "/camera_rgb_optical_frame",
                                        self.front_intrinsic, self.lidarpixels_frontcamera,
                                        self.lidarpixelsbig_frontcamera, self.lidarcoordbig_frontcamera)

    def lidar_points_to_pixels(self, posestamped, frame, intrinsic, output, output2, coord_output):
        # Get the laser points in the camera frame
        transform = self.tf_buffer.lookup_transform(frame,
                                                    posestamped.header.frame_id,
                                                    posestamped.header.stamp,
                                                    rospy.Duration(1))
        lidarpoint_camera = tf2_geometry_msgs.do_transform_pose(posestamped, transform)
        # Transform to pixels
        lidarpixel_camera_aux1 = np.dot(intrinsic,
                                        np.array([[lidarpoint_camera.pose.position.x],
                                                  [lidarpoint_camera.pose.position.y],
                                                  [lidarpoint_camera.pose.position.z]]))
        lidarpixel_camera_aux2 = np.array(
            [[lidarpixel_camera_aux1[0, 0] / lidarpixel_camera_aux1[2, 0]],
             [lidarpixel_camera_aux1[1, 0] / lidarpixel_camera_aux1[2, 0]]])
        # Get only the pixels that matter
        if 0 < lidarpixel_camera_aux2[0, 0] < self.front_width and 0 < lidarpixel_camera_aux2[1, 0] < self.front_height:
            lidarpixel_camera = np.array([[round(lidarpixel_camera_aux2[0, 0])], [round(lidarpixel_camera_aux2[1, 0])]])
            output.append(lidarpixel_camera)

        # Making sure that the coordenate matrix is the same for getting the pixels and the future reversing the process
        coord_base_scan = (posestamped.pose.position.x, posestamped.pose.position.y, posestamped.pose.position.z)

        # Get a pixel matrix of the same size of points matrix for reversing process
        try:
            lidarpixel_camera_aux3 = np.array([[round(lidarpixel_camera_aux2[0, 0])], [round(lidarpixel_camera_aux2[1, 0])]])
        except ValueError:
            lidarpixel_camera_aux3 = np.array([[math.inf], [math.inf]])

        output2.append(lidarpixel_camera_aux3)
        coord_output.append(coord_base_scan)

    def image_lidar(self):
        for item in self.lidarpixels_frontcamera:
            cv2.drawMarker(self.frontcameraimage, (item[0, 0], item[1, 0]), (0, 0, 255), markerType=cv2.MARKER_STAR,
                           markerSize=40, thickness=2, line_type=cv2.LINE_AA)
        for item in self.lidarpixels_backcamera:
            cv2.drawMarker(self.backcameraimage, (item[0, 0], item[1, 0]), (0, 0, 255), markerType=cv2.MARKER_STAR,
                           markerSize=40, thickness=2, line_type=cv2.LINE_AA)
        cv2.imshow(self.player + ' frontal', self.frontcameraimage)
        cv2.imshow(self.player + ' traseira', self.backcameraimage)
        cv2.waitKey(1)

    def Centroid(self, image, centroid_data, team):
        mask_team = cv2.inRange(image, self.team_colors[0], self.team_colors[1])
        mask_hunter = cv2.inRange(image, self.hunter_colors[0], self.hunter_colors[1])
        mask_prey = cv2.inRange(image, self.prey_colors[0], self.prey_colors[1])
        if team == 'Team':
            self.getCentroid(mask_team, centroid_data)
        if team == 'Hunter':
            self.getCentroid(mask_hunter, centroid_data)
        if team == 'Prey':
            self.getCentroid(mask_prey, centroid_data)

    def getCentroid(self, mask, centroid_data):
        # Remove noise from mask
        maskcopy = mask.copy()
        cnts_aux1, _ = cv2.findContours(maskcopy, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
        for c in cnts_aux1:
            area = cv2.contourArea(c)
            if area > 25:
                cv2.drawContours(maskcopy, c, -1, (255, 255, 255), 25)
        mask2 = cv2.morphologyEx(maskcopy, cv2.MORPH_OPEN, np.ones((5, 5), np.uint8), iterations=2)
        mask3 = cv2.dilate(mask2, np.ones((6, 6), np.uint8), iterations=2)
        # Get new contours
        contours, _ = cv2.findContours(mask3, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
        for c in contours:
            # calculate moments for each contour
            M = cv2.moments(c)
            # calculate x,y coordinate of center
            if M["m00"] != 0:
                cX = int(M["m10"] / M["m00"])
                cY = int(M["m01"] / M["m00"])
            else:
                cX, cY = 0, 0
            centroid_data.append((cX, cY))
    def centroid_to_lidar(self, centroid, lidar_pixels, lidar_coord, lidar_pixels_big):
        # Transform list of arrays to list of points
        lidar_pixels_big_list = []
        for array in lidar_pixels_big:
            lX = array[0, 0]
            lY = array[1, 0]
            lidar_pixels_big_list.append((lX, lY))
        # Look for coordenates only if there is a robot in the images
        if centroid != [] and lidar_pixels != []:
            lidar_point = []
            coord_list = []
            # Get the closest laser pixels to the centroids
            for i in centroid:
                cX = i[0]
                cY = i[1]
                dist = math.inf
                lidar = (math.inf, math.inf)
                for idx in lidar_pixels:
                    lX = idx[0, 0]
                    lY = idx[1, 0]
                    distance = math.sqrt((cX-lX)**2 + (cY-lY)**2)
                    if distance < dist:
                        dist = distance
                        lidar = (lX, lY)
                lidar_point.append(lidar)
            # Get the index of the pixels from the previous step
            idx_all = []
            for point in lidar_point:
                idx = lidar_pixels_big_list.index(point)
                idx_all.append(idx)
            # Get the coordenate in the base_link frame by comparation
            for idx in idx_all:
                coord = lidar_coord[idx]
                coord_list.append(coord)
        else:
            coord_list = []
        return coord_list

    def goToGoal(self,minimum_speed=0.1,maximum_speed=2):
        goal_copy = copy.deepcopy(self.goal)
        goal_copy.header.stamp = rospy.Time.now()
        print('Tranforming pose')
        goal_in_base_lik = self.tf_buffer.transform(goal_copy, self.player + '/base_footprint', rospy.Duration(1))
        print('Pose Transformed')

        x=goal_in_base_lik.pose.position.x
        y=goal_in_base_lik.pose.position.y

        self.angle = math.atan2(y,x)
        distance_to_goal=math.sqrt(x**2+y**2)

        # limit minimun speed
        self.speed=max(minimum_speed,0.5*distance_to_goal)
        # limitmaximum speed
        self.speed=min(maximum_speed,self.speed)


    def sendCommandCallback(self, event):

        print('Sending twist command')

        if self.manual_goal_active == True:
            self.goToGoal()

        twist = Twist()
        twist.linear.x = self.speed
        twist.angular.z = self.angle
        self.publisher_command.publish(twist)

def main():
    rospy.init_node('p_g3_driver', anonymous=False)
    rospy.loginfo("I'm " + Driver().player + ", from team " + Driver().team +
                  "\nI want to catch " + Driver().prey + " but I fear " + Driver().hunter)
    rospy.spin()


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
