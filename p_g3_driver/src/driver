#!/usr/bin/env python3

import numpy as np
import rospy
from sensor_msgs.msg import Image, LaserScan, CameraInfo
from tf2_geometry_msgs import PoseStamped, tf2_geometry_msgs
from geometry_msgs.msg import Point
from cv_bridge import CvBridge
import cv2
import message_filters
import math
import tf2_ros
import copy


class Driver:
    def __init__(self):
        # ---------------------------------------------------
        #   Get team, hunter and prey
        # ---------------------------------------------------
        self.team = ''
        self.hunter = ''
        self.prey = ''
        self.player = ''
        self.allplayers = ''
        self.team_identification()
        # ---------------------------------------------------
        #   Topics to subscribe and subscription
        # ---------------------------------------------------
        topic_camera = "/" + self.player + '/camera/rgb/image_raw'
        topic_backcamera = "/" + self.player + '/back_camera/rgb/image_raw'
        topic_camera_info = "/" + self.player + '/camera/rgb/camera_info'
        topic_backcamera_info = "/" + self.player + '/back_camera/rgb/camera_info'
        topic_laser = "/" + self.player + '/scan'
        self.subscriber_laser = rospy.Subscriber(topic_laser, LaserScan, self.getLidarPointsCallback)
        self.subscriber_camera = message_filters.Subscriber(topic_camera, Image)
        self.subscriber_backcamera = message_filters.Subscriber(topic_backcamera, Image)
        self.subscriber_camera_info = message_filters.Subscriber(topic_camera_info, CameraInfo)
        self.subscriber_backcamera_info = message_filters.Subscriber(topic_backcamera_info, CameraInfo)
        # ---------------------------------------------------
        #   Masks
        # ---------------------------------------------------
        # TODO Verificar valores
        #   Red color
        lower_red = np.array([0, 0, 90])
        upper_red = np.array([40, 40, 256])
        #   Green color
        lower_green = np.array([0, 90, 0])
        upper_green = np.array([40, 256, 40])
        #   Blue color
        lower_blue = np.array([90, 0, 0])
        upper_blue = np.array([256, 40, 40])
        # ---------------------------------------------------
        #   Get image from the cameras
        # ---------------------------------------------------
        self.bridge = CvBridge()
        self.backcameraimage = None
        self.frontcameraimage = None
        ts_image = message_filters.TimeSynchronizer([self.subscriber_camera, self.subscriber_backcamera], 1)
        ts_image.registerCallback(self.getCameraCallback)
        # ---------------------------------------------------
        #   Get info from the cameras
        # ---------------------------------------------------
        self.front_intrinsic = None
        self.front_width = None
        self.front_height = None
        self.back_intrinsic = None
        self.back_width = None
        self.back_height = None
        ts_imageinfo = message_filters.TimeSynchronizer([self.subscriber_camera_info, self.subscriber_backcamera_info],
                                                        1)
        ts_imageinfo.registerCallback(self.getCameraInfoCallback)
        # ---------------------------------------------------
        #   Laser points
        # ---------------------------------------------------
        self.lidarpoints_frontcamera = []
        self.lidarpoints_backcamera = []
        self.lidarpixels_frontcamera = []
        self.lidarpixels_backcamera = []
        self.tf_buffer = tf2_ros.Buffer()
        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer)

    def team_identification(self):
        self.allplayers = {'red': rospy.get_param('/red_players'),
                           'green': rospy.get_param('/green_players'),
                           'blue': rospy.get_param('/blue_players')}
        self.player = rospy.get_name().strip('/')
        if self.player in self.allplayers['red']:
            self.team = 'red'
            self.hunter = 'blue'
            self.prey = 'green'
        elif self.player in self.allplayers['green']:
            self.team = 'green'
            self.hunter = 'red'
            self.prey = 'blue'
        elif self.player in self.allplayers['blue']:
            self.team = 'blue'
            self.hunter = 'green'
            self.prey = 'red'
        else:
            self.team = 'Alone'
            self.hunter = 'No one'
            self.prey = 'No one'

    def getCameraCallback(self, msg_front, msg_back):
        self.frontcameraimage = self.bridge.imgmsg_to_cv2(msg_front, "bgr8")
        self.backcameraimage = self.bridge.imgmsg_to_cv2(msg_back, "bgr8")
        self.image_lidar()
        # print('back')
        # print(self.lidarpixels_backcamera)
        # print('front')
        # print(self.lidarpixels_frontcamera)

        # TODO Meter parametro para escolher visualizar imagem ou n√£o
        # Testing
        # cv2.imshow('frente', self.frontcameraimage)
        # cv2.imshow('tras', self.backcameraimage)
        # cv2.waitKey(1)

    def getCameraInfoCallback(self, msg_front, msg_back):
        self.front_height = msg_front.height
        self.front_width = msg_front.width
        self.front_intrinsic = np.asarray(msg_front.K).reshape(3, 3)
        self.back_height = msg_back.height
        self.back_width = msg_back.width
        self.back_intrinsic = np.asarray(msg_back.K).reshape(3, 3)
        # Testing
        # print(self.player + ' Frontal')
        # print(self.front_intrinsic)
        # print(self.player + ' Traseira')
        # print(self.back_intrinsic)

    def getLidarPointsCallback(self, msg):
        z = 0
        for idx, range in enumerate(msg.ranges):
            theta = msg.angle_min + idx * msg.angle_increment
            x = range * math.cos(theta)
            y = range * math.sin(theta)
            posestamped = PoseStamped()
            posestamped.header.frame_id = self.player + "/base_scan"
            posestamped.header.stamp = rospy.Time(0)
            point = Point()
            point.x = x
            point.y = y
            point.z = z
            posestamped.pose.position = point
            posestamped_front = copy.deepcopy(posestamped)
            posestamped_back = copy.deepcopy(posestamped)
            if posestamped_front.pose.position.x < 0:
                posestamped_front.pose.position.x = math.inf
                posestamped_front.pose.position.y = math.inf
            if posestamped_back.pose.position.x > 0:
                posestamped_back.pose.position.x = math.inf
                posestamped_back.pose.position.y = math.inf
            print(posestamped_front.pose.position.x)
            self.lidar_points_to_pixels(posestamped_back, self.player + "/back_camera_rgb_optical_frame",
                                        self.back_intrinsic, self.lidarpixels_backcamera)
            self.lidar_points_to_pixels(posestamped_front, self.player + "/camera_rgb_optical_frame", self.front_intrinsic,
                                        self.lidarpixels_frontcamera)

    def lidar_points_to_pixels(self, posestamped, frame, intrinsic, output):
        transform = self.tf_buffer.lookup_transform(frame,
                                                    posestamped.header.frame_id,
                                                    posestamped.header.stamp,
                                                    rospy.Duration(1))
        lidarpoint_camera = tf2_geometry_msgs.do_transform_pose(posestamped, transform)
        lidarpixel_camera_aux1 = np.dot(intrinsic,
                                        np.array([[lidarpoint_camera.pose.position.x],
                                                  [lidarpoint_camera.pose.position.y],
                                                  [lidarpoint_camera.pose.position.z]]))
        lidarpixel_camera_aux2 = np.array(
            [[lidarpixel_camera_aux1[0, 0] / lidarpixel_camera_aux1[2, 0]],
             [lidarpixel_camera_aux1[1, 0] / lidarpixel_camera_aux1[2, 0]]])
        if 0 < lidarpixel_camera_aux2[0, 0] < self.front_width and 0 < lidarpixel_camera_aux2[1, 0] < self.front_height:
            lidarpixel_camera = np.array([[round(lidarpixel_camera_aux2[0, 0])], [round(lidarpixel_camera_aux2[1, 0])]])
            output.append(lidarpixel_camera)

    def image_lidar(self):
        for item in self.lidarpixels_frontcamera:
            cv2.drawMarker(self.frontcameraimage, (item[0, 0], item[1, 0]), (0, 0, 255), markerType=cv2.MARKER_STAR,
                           markerSize=40, thickness=2, line_type=cv2.LINE_AA)
        for item in self.lidarpixels_backcamera:
            cv2.drawMarker(self.backcameraimage, (item[0, 0], item[1, 0]), (0, 0, 255), markerType=cv2.MARKER_STAR,
                           markerSize=40, thickness=2, line_type=cv2.LINE_AA)
        cv2.imshow(self.player + ' frontal', self.frontcameraimage)
        cv2.imshow(self.player + ' traseira', self.backcameraimage)
        cv2.waitKey(1)


def main():
    rospy.init_node('p_g3_driver', anonymous=False)
    rospy.loginfo("I'm " + Driver().player + ", from team " + Driver().team +
                  "\nI want to catch " + Driver().prey + " but I fear " + Driver().hunter)
    rospy.spin()


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
